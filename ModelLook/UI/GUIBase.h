#ifndef UI_GUIBase_h
#define UI_GUIBase_h

#include "UI.h"

//平台相关接口与数据结构
namespace platform
{
#ifdef PLATFORM_WIN32
	//平台相关的屏幕坐标单位
	using unit_type = long;
	//平台相关的屏幕坐标距离
	using unitlength_type = unsigned long;
#else
#error "unsupprot platform"
#endif
}

LEO_DRAW_BEGIN

/*!
\brief 屏幕二元组。
\warning 非虚析构。
*/
template<typename _type>
class GBinaryGroup
{
public:
	static const GBinaryGroup Invalid; //!< 无效（不在屏幕坐标系中）对象。

	_type X = 0, Y = 0; //!< 分量。

						/*!
						\brief 无参数构造。
						\note 零初始化。
						\since build 319
						*/
	lconstfn DefDeCtor(GBinaryGroup)
		/*!
		\brief 复制构造：默认实现。
		*/
		lconstfn DefDeCopyCtor(GBinaryGroup)
		/*!
		\brief 构造：使用 Size 对象。
		\since build 319
		*/
		explicit lconstfn
		GBinaryGroup(const Size&) lnothrow;
	/*!
	\brief 构造：使用 Rect 对象。
	\since build 319
	*/
	explicit lconstfn
		GBinaryGroup(const Rect&) lnothrow;
	/*!
	\brief 构造：使用两个纯量。
	\tparam _tScalar1 第一分量纯量类型。
	\tparam _tScalar2 第二分量纯量类型。
	\warning 模板参数和 _type 符号不同时隐式转换可能改变符号，不保证唯一结果。
	*/
	template<typename _tScalar1, typename _tScalar2>
	lconstfn
		GBinaryGroup(_tScalar1 x, _tScalar2 y) lnothrow
		: X(_type(x)), Y(_type(y))
	{}
	/*!
	\brief 构造：使用纯量对。
	\note 使用 std::get 取分量。仅取前两个分量。
	*/
	template<typename _tPair>
	lconstfn
		GBinaryGroup(const _tPair& pr) lnothrow
		: X(std::get<0>(pr)), Y(std::get<1>(pr))
	{}

	//! \since build 554
	DefDeCopyAssignment(GBinaryGroup)

		/*!
		\brief 负运算：取加法逆元。
		*/
		lconstfn PDefHOp(GBinaryGroup, -, ) const lnothrow
		ImplRet(GBinaryGroup(-X, -Y))

		/*!
		\brief 加法赋值。
		*/
		PDefHOp(GBinaryGroup&, +=, const GBinaryGroup& val) lnothrow
		ImplRet(lunseq(X += val.X, Y += val.Y), *this)
		/*!
		\brief 减法赋值。
		*/
		PDefHOp(GBinaryGroup&, -=, const GBinaryGroup& val) lnothrow
		ImplRet(lunseq(X -= val.X, Y -= val.Y), *this)

		lconstfn DefGetter(const lnothrow, _type, X, X)
		lconstfn DefGetter(const lnothrow, _type, Y, Y)

		DefSetter(_type, X, X)
		DefSetter(_type, Y, Y)

		/*!
		\brief 判断是否是零元素。
		*/
		lconstfn DefPred(const lnothrow, Zero, X == 0 && Y == 0)

		/*!
		\brief 选择分量引用。
		\note 第二参数为 true 时选择第一分量，否则选择第二分量。
		*/
		//@{
		PDefH(_type&, GetRef, bool b = true) lnothrow
		ImplRet(b ? X : Y)
		PDefH(const _type&, GetRef, bool b = true) const lnothrow
		ImplRet(b ? X : Y)
		//@}
};

//! \relates GBinaryGroup
//@{
template<typename _type>
const GBinaryGroup<_type> GBinaryGroup<_type>::Invalid{
	std::numeric_limits<_type>::lowest(), std::numeric_limits<_type>::lowest() };

template<typename _type>
lconstfn bool
operator==(const GBinaryGroup<_type>& x, const GBinaryGroup<_type>& y) lnothrow
{
	return x.X == y.X && x.Y == y.Y;
}

template<typename _type>
lconstfn bool
operator!=(const GBinaryGroup<_type>& x, const GBinaryGroup<_type>& y) lnothrow
{
	return !(x == y);
}

template<typename _type>
lconstfn GBinaryGroup<_type>
operator+(const GBinaryGroup<_type>& x, const GBinaryGroup<_type>& y) lnothrow
{
	return GBinaryGroup<_type>(x.X + y.X, x.Y + y.Y);
}

template<typename _type>
lconstfn GBinaryGroup<_type>
operator-(const GBinaryGroup<_type>& x, const GBinaryGroup<_type>& y) lnothrow
{
	return GBinaryGroup<_type>(x.X - y.X, x.Y - y.Y);
}

template<typename _type, typename _tScalar>
lconstfn GBinaryGroup<_type>
operator*(const GBinaryGroup<_type>& val, _tScalar l) lnothrow
{
	return GBinaryGroup<_type>(val.X * l, val.Y * l);
}

template<class _tBinary>
lconstfn _tBinary
Transpose(const _tBinary& obj) lnothrow
{
	return _tBinary(obj.Y, obj.X);
}

template<size_t _vIdx, typename _type>
lconstfn _type&
get(GBinaryGroup<_type>& val)
{
	static_assert(_vIdx < 2, "Invalid index found.");

	return _vIdx == 0 ? val.X : val.Y;
}
template<size_t _vIdx, typename _type>
lconstfn const _type&
get(const GBinaryGroup<_type>& val)
{
	static_assert(_vIdx < 2, "Invalid index found.");

	return _vIdx == 0 ? val.X : val.Y;
}

/*!
\brief 屏幕二维点(直角坐标)
*/
using Point = GBinaryGroup<platform::unit_type>;
using Vec = GBinaryGroup<platform::unit_type>;

/*!
\brief 屏幕区域大小
*/
struct LB_API Size
{
	/*!
	\brief 无效对象
	*/
	static const Size Invalid;

	using PDst = platform::unitlength_type;
	platform::unitlength_type Width, Height;

	DefGetter(const lnothrow, platform::unitlength_type, Height, Height)
		DefGetter(const lnothrow, platform::unitlength_type, Width, Width)
		DefSetter(platform::unitlength_type, Height, Height)
		DefSetter(platform::unitlength_type, Width, Width)
		/*!
		\brief 无参数构造
		\warning 零初始化。
		*/
		lconstfn Size() lnothrow
		:Width(0), Height(0)
	{}

	lconstfn Size(const Size& s) lnothrow
		: Width(s.Width), Height(s.Height)
	{}

	template<typename Scalar1, typename Scalar2>
	lconstfn Size(Scalar1 w, Scalar2 h) lnothrow
		: Width(static_cast<PDst>(w)), Height(static_cast<PDst>(h))
	{}

	template<typename Scalar1, typename Scalar2>
	lconstfn Size(std::pair<Scalar1, Scalar1> s) lnothrow
		: Width(static_cast<PDst>(s.first)), Height(static_cast<PDst>(s.second))
	{}

	DefDeCopyAssignment(Size)

		lconstfn DefBoolNeg(lconstfn explicit, Width != 0 || Height != 0)

		/*!
		\brief 求与另外一个区域的交
		*/
		PDefHOp(Size&, &=, const Size& s) lnothrow
		ImplRet(lunseq(Width = std::min(Width, s.Width),
			Height = std::min(Height, s.Height)), *this)

		/*!
		\brief 求与另外一个区域的并
		*/
		PDefHOp(Size&, |=, const Size& s) lnothrow
		ImplRet(lunseq(Width = std::max(Width, s.Width),
			Height = std::max(Height, s.Height)), *this)

		/*!
		\brief 判断是否为线段
		*/
		lconstfn DefPred(const lnothrow, LineSegment, !((Width == 0) ^ (Height == 0)))

		lconstfn DefPred(const lnothrow, UnStrictlyEmpty, Width == 0 || Height == 0)
};

lconstfn PDefHOp(bool, == , const Size& x, const Size& y) lnothrow
ImplRet(x.Width == y.Width && x.Height == y.Height)

lconstfn PDefHOp(bool, != , const Size& x, const Size& y) lnothrow
ImplRet(!(x == y))

lconstfn PDefHOp(Size, &, const Size& x, const Size& y) lnothrow
ImplRet({ std::min(x.Width, y.Width),std::min(x.Height, y.Height) })

lconstfn PDefHOp(Size, | , const Size& x, const Size& y) lnothrow
ImplRet({ std::max(x.Width, y.Width), std::max(x.Height, y.Height) })

lconstfn PDefH(size_t, GetAreaOf, const Size& s) lnothrow
ImplRet(size_t(s.Width * s.Height))


template<size_t _vIdx>
lconstfn platform::unitlength_type&
get(Size& s)
{
	static_assert(_vIdx < 2, "Invalid index found.");

	return _vIdx == 0 ? s.Width : s.Height;
}
template<size_t _vIdx>
lconstfn const platform::unitlength_type&
get(const Size& s)
{
	static_assert(_vIdx < 2, "Invalid index found.");

	return _vIdx == 0 ? s.Width : s.Height;
}


template<typename _type>
lconstfn GBinaryGroup<_type>
operator+(GBinaryGroup<_type> val, const Size& s) lnothrow
{
	// XXX: Conversion to '_type' might be implementation-defined.
	return{ val.X + _type(s.Width), val.Y + _type(s.Height) };
}

template<typename _type>
lconstfn GBinaryGroup<_type>
operator-(GBinaryGroup<_type> val, const Size& s) lnothrow
{
	// XXX: Conversion to '_type' might be implementation-defined.
	return{ val.X - _type(s.Width), val.Y - _type(s.Height) };
}

lconstfn PDefH(Size, Transpose, const Size& s) lnothrow
ImplRet({ s.Height, s.Width })

struct LB_API Rect :private Point, private Size
{
	static const Rect Invalid;
	using Point::X;
	using Point::Y;
	using Size::Width;
	using Size::Height;

	DefDeCtor(Rect)

		explicit lconstfn
		Rect(const Point& pt) lnothrow
		:Point(pt), Size()
	{}

	/*!
	\brief 构造：使用 Size 对象。
	*/
	lconstfn
		Rect(const Size& s) lnothrow
		: Point(), Size(s)
	{}
	/*!
	\brief 构造：使用屏幕二维点和 Size 对象。
	*/
	lconstfn
		Rect(const Point& pt, const Size& s) lnothrow
		: Point(pt), Size(s)
	{}
	/*!
	\brief 构造：使用屏幕二维点和表示长宽的两个 platform::unitlength_type 值。
	*/
	lconstfn
		Rect(const Point& pt, platform::unitlength_type w, platform::unitlength_type h) lnothrow
		: Point(pt.X, pt.Y), Size(w, h)
	{}
	/*!
	\brief 构造：使用表示位置的两个 platform::unit_type 值和 Size 对象。
	*/
	lconstfn
		Rect(platform::unit_type x, platform::unit_type y, const Size& s) lnothrow
		: Point(x, y), Size(s.Width, s.Height)
	{}
	/*!
	\brief 构造：使用表示位置的两个 platform::unit_type 值和表示大小的两个 platform::unitlength_type 值。
	*/
	lconstfn
		Rect(platform::unit_type x, platform::unit_type y, platform::unitlength_type w, platform::unitlength_type h) lnothrow
		: Point(x, y), Size(w, h)
	{}
	/*!
	\brief 复制构造：默认实现。
	*/
	lconstfn DefDeCopyCtor(Rect)

		DefDeCopyAssignment(Rect)
		//! \since build 319
		//@{
		Rect&
		operator=(const Point& pt) lnothrow
	{
		lunseq(X = pt.X, Y = pt.Y);
		return *this;
	}
	Rect&
		operator=(const Size& s) lnothrow
	{
		lunseq(Width = s.Width, Height = s.Height);
		return *this;
	}
	//@}

	/*!
	\brief 求与另一个屏幕标准矩形的交。
	\note 若相离结果为 Rect() ，否则为包含于两个参数中的最大矩形。
	*/
	Rect&
		operator&=(const Rect&) lnothrow;

	/*!
	\brief 求与另一个屏幕标准矩形的并。
	\note 结果为包含两个参数中的最小矩形。
	*/
	Rect&
		operator|=(const Rect&) lnothrow;

	/*!
	\brief 判断是否为空。
	\sa Size::operator!
	*/
	using Size::operator!;

	/*!
	\brief 判断是否非空。
	\sa Size::bool
	*/
	using Size::operator bool;

	/*!
	\brief 判断点 (px, py) 是否在矩形内或边上。
	*/
	bool
		Contains(platform::unit_type px, platform::unit_type py) const lnothrow;
	/*!
	\brief 判断点 pt 是否在矩形内或边上。
	*/
	PDefH(bool, Contains, const Point& pt) const lnothrow
		ImplRet(Contains(pt.X, pt.Y))
		/*!
		\brief 判断矩形是否在矩形内或边上。
		\note 空矩形总是不被包含。
		*/
		bool
		Contains(const Rect&) const lnothrow;
	/*!
	\brief 判断点 (px, py) 是否在矩形内。
	*/
	bool
		ContainsStrict(platform::unit_type px, platform::unit_type py) const lnothrow;
	/*!
	\brief 判断点 pt 是否在矩形内。
	*/
	PDefH(bool, ContainsStrict, const Point& pt) const lnothrow
		ImplRet(ContainsStrict(pt.X, pt.Y))
		/*!
		\brief 判断矩形是否在矩形内或边上。
		\note 空矩形总是不被包含。
		*/
		bool
		ContainsStrict(const Rect&) const lnothrow;
	/*!
	\brief 判断矩形是否为线段：长和宽中有且一个数值等于 0 。
	\sa Size::IsLineSegment
	*/
	using Size::IsLineSegment;

	using Size::IsUnStrictlyEmpty;

	// XXX: Conversion to 'platform::unit_type' might be implementation-defined.
	lconstfn DefGetter(const lnothrow, platform::unit_type, Bottom, Y + platform::unit_type(Height))
		/*!
		\brief 取左上角位置。
		*/
		lconstfn DefGetter(const lnothrow, const Point&, Point,
			static_cast<const Point&>(*this))
		/*!
		\brief 取左上角位置引用。
		*/
		DefGetter(lnothrow, Point&, PointRef, static_cast<Point&>(*this))
		// XXX: Conversion to 'platform::unit_type' might be implementation-defined.
		lconstfn DefGetter(const lnothrow, platform::unit_type, Right, X + platform::unit_type(Width))
		/*!
		\brief 取大小。
		*/
		lconstfn DefGetter(const lnothrow, const Size&, Size,
			static_cast<const Size&>(*this))
		/*!
		\brief 取大小引用。
		*/
		DefGetter(lnothrow, Size&, SizeRef, static_cast<Size&>(*this))

		using Point::GetX;
	using Point::GetY;

	using Point::SetX;
	using Point::SetY;
	//@}
};

struct LB_API Box :public Rect
{
	using Rect::Rect;
};

//! \relates Rect
//@{
/*!
\brief 比较：屏幕标准矩形相等关系。
*/
lconstfn PDefHOp(bool, == , const Rect& x, const Rect& y) lnothrow
ImplRet(x.GetPoint() == y.GetPoint() && x.GetSize() == y.GetSize())

/*!
\brief 比较：屏幕标准矩形不等关系。
*/
lconstfn PDefHOp(bool, != , const Rect& x, const Rect& y) lnothrow
ImplRet(!(x == y))

/*!
\brief 加法：使用标准矩形 r 和偏移向量 v 构造屏幕标准矩形。
*/
lconstfn PDefHOp(Rect, +, const Rect& r, const Vec& v) lnothrow
ImplRet({ r.GetPoint() + v, r.GetSize() })

/*!
\brief 减法：使用标准矩形 r 和偏移向量的加法逆元 v 构造屏幕标准矩形。
*/
lconstfn PDefHOp(Rect, -, const Rect& r, const Vec& v) lnothrow
ImplRet({ r.GetPoint() - v, r.GetSize() })

/*!
\brief 求两个屏幕标准矩形的交。
\sa Rect::operator&=
*/
inline PDefHOp(Rect, &, const Rect& x, const Rect& y) lnothrow
ImplRet(Rect(x) &= y)

/*!
\brief 求两个屏幕标准矩形的并。
\sa Rect::operator|=
*/
inline PDefHOp(Rect, | , const Rect& x, const Rect& y) lnothrow
ImplRet(Rect(x) |= y)

/*!
\brief 剪切操作：取标准矩形交集并判断是否严格非空。
*/
inline PDefH(bool, Clip, Rect& x, const Rect& y)
ImplRet(x &= y, !x.IsUnStrictlyEmpty())

LEO_DRAW_END

LEO_BEGIN
/*!
\brief 判断 i 是否在左闭右开区间 [_type(0), b) 中。
\pre 断言： <tt>_type(0) < b</tt> 。
*/
template<typename _type>
inline bool
IsInInterval(_type i, _type b) lnothrow
{
	LAssert(_type(0) < b,
		"Zero element as lower bound is not less than upper bound.");
	return !(i < _type(0)) && i < b;
}

/*!
\brief 判断 i 是否在左闭右开区间 [a, b) 中。
\pre 断言： <tt>a < b</tt> 。
*/
template<typename _type>
inline bool
IsInInterval(_type i, _type a, _type b) lnothrow
{
	LAssert(a < b, "Lower bound is not less than upper bound.");
	return !(i < a) && i < b;
}

/*!
\brief 判断 i 是否在闭区间 [_type(0), b] 中。
\pre 断言： <tt>_type(0) < b</tt> 。
*/
template<typename _type>
inline bool
IsInClosedInterval(_type i, _type b) lnothrow
{
	LAssert(_type(0) < b,
		"Zero element as lower bound is not less than upper bound.");
	return !(i < _type(0) || b < i);
}
/*!
\brief 判断 i 是否在闭区间 [a, b] 中。
\pre 断言： <tt>a < b</tt> 。
*/
template<typename _type>
inline bool
IsInClosedInterval(_type i, _type a, _type b) lnothrow
{
	LAssert(a < b, "Lower bound is not less than upper bound.");
	return !(i < a || b < i);
}

/*!
\brief 判断 i 是否在开区间 (_type(0), b) 内。
\pre 断言： <tt>_type(0) < b</tt> 。
*/
template<typename _type>
inline bool
IsInOpenInterval(_type i, _type b) lnothrow
{
	LAssert(_type(0) < b,
		"Zero element as lower bound is not less than upper bound.");
	return _type(0) < i && i < b;
}
/*!
\brief 判断 i 是否在开区间 (a, b) 内。
\pre 断言： <tt>a < b</tt> 。
*/
template<typename _type>
inline bool
IsInOpenInterval(_type i, _type a, _type b) lnothrow
{
	LAssert(a < b, "Lower bound is not less than upper bound.");
	return a < i && i < b;
}

LEO_END


#endif
