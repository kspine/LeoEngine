#ifdef GL
#define L3D_FLIPPING 1.f
#else
#define L3D_FLIPPING -1.f
#endif

// Encoding a[0, 1) float into a rgba8.
//From http ://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
float4 EncodeFloatRGBA(float v)
{
	float4 enc = float4(1.0f, 255.0f, 65025.0f, 16581375.0f) * v;
	enc = frac(enc);
	enc -= enc.yzww * float4(1 / 255.0f, 1 / 255.0f, 1 / 255.0f, 0);
	return enc;
}

float DecodeFloatRGBA(float4 rgba)
{
	return dot(rgba, float4(1, 1 / 255.0f, 1 / 65025.0f, 1 / 16581375.0f));
}

float4 WriteAFloat(float v, float scale = 1, float bias = 0)
{
	#ifdef NO_SINGLE_CHANNEL_FLOAT
	return EncodeFloatRGBA(clamp(v * scale + bias, 0, 0.999f));
	#else
	return v;
	#endif
}

float ReadAFloat(float4 v, float scale = 1, float bias = 0)
{
	#ifdef NO_SINGLE_CHANNEL_FLOAT
	return DecodeFloatRGBA(v) * scale + bias;
	#else
	return v.r;
	#endif
}

float2 TexCoordFromPos(float4 pos)
{
	float2 tex = pos.xy / 2;
	tex.y *= L3D_FLIPPING;
	tex += 0.5;
	return tex;
}

float3 NormalSampleCalc(float3 normalMapSample, float3 unitNormal, float3 tangent)
{
	// Uncompress each component from [0,1] to [-1,1].
	float3 normalT = 2.0f*normalMapSample - 1.0f;

	// Build orthonormal basis.
	float3 N = unitNormal;
	float3 T = normalize(tangent - dot(tangent, N)*N);
	float3 B = cross(N, T);

	float3x3 TBN = float3x3(T, B, N);

	// Transform from tangent space to world space.
	float3 bumpedNormalW = mul(normalT, TBN);

	return bumpedNormalW;
}